(self.webpackChunkweave_gitops_docs=self.webpackChunkweave_gitops_docs||[]).push([[4539],{3905:function(e,t,n){"use strict";n.d(t,{Zo:function(){return c},kt:function(){return d}});var o=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,o,i=function(e,t){if(null==e)return{};var n,o,i={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=o.createContext({}),p=function(e){var t=o.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},c=function(e){var t=p(e.components);return o.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,c=r(e,["components","mdxType","originalType","parentName"]),u=p(n),d=i,g=u["".concat(l,".").concat(d)]||u[d]||m[d]||a;return n?o.createElement(g,s(s({ref:t},c),{},{components:n})):o.createElement(g,s({ref:t},c))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,s=new Array(a);s[0]=u;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:i,s[1]=r;for(var p=2;p<a;p++)s[p]=n[p];return o.createElement.apply(null,s)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},25848:function(e,t,n){"use strict";n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return r},metadata:function(){return l},toc:function(){return p},default:function(){return m}});var o=n(22122),i=n(19756),a=(n(67294),n(3905)),s={sidebar_position:8},r="Deploying the Sock Shop Application",l={unversionedId:"examples/sock-shop",id:"version-0.5.0/examples/sock-shop",isDocsHomePage:!1,title:"Deploying the Sock Shop Application",description:"In this example, we'll show how easy it is to deploy a real world application using Weave GitOps. The Sock Shop is a well known microservices application that is widely used in demonstration and testing of microservice environments such as Kubernetes. We'll actually see two different ways of deploying the Sock Shop:",source:"@site/versioned_docs/version-0.5.0/examples/sock-shop.md",sourceDirName:"examples",slug:"/examples/sock-shop",permalink:"/docs/examples/sock-shop",editUrl:"https://github.com/weaveworks/weave-gitops-docs/edit/main/versioned_docs/version-0.5.0/examples/sock-shop.md",version:"0.5.0",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"version-0.5.0/tutorialSidebar",previous:{title:"AWS Marketplace",permalink:"/docs/aws-marketplace"},next:{title:"GitOps Automation Configuration",permalink:"/docs/gitops-automation"}},p=[{value:"Deploying with Weave GitOps",id:"deploying-with-weave-gitops",children:[{value:"Using Helm Charts",id:"using-helm-charts",children:[]},{value:"Single Repository Usage",id:"single-repository-usage",children:[]},{value:"Using Pull Requests",id:"using-pull-requests",children:[]}]}],c={toc:p};function m(e){var t=e.components,s=(0,i.Z)(e,["components"]);return(0,a.kt)("wrapper",(0,o.Z)({},c,s,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"deploying-the-sock-shop-application"},"Deploying the Sock Shop Application"),(0,a.kt)("p",null,"In this example, we'll show how easy it is to deploy a real world application using Weave GitOps. The ",(0,a.kt)("em",{parentName:"p"},"Sock Shop")," is a well known microservices application that is widely used in demonstration and testing of microservice environments such as Kubernetes. We'll actually see two different ways of deploying the ",(0,a.kt)("em",{parentName:"p"},"Sock Shop"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"as a plain set of Kubernetes manifests"),(0,a.kt)("li",{parentName:"ul"},"as a helm chart")),(0,a.kt)("h1",{id:"prerequisites"},"Prerequisites"),(0,a.kt)("p",null,"In order to deploy the ",(0,a.kt)("em",{parentName:"p"},"Sock Shop"),", you need to first deploy Weave GitOps to a Kubernetes cluster. If you'd like to test this out locally, you can set up a ",(0,a.kt)("a",{parentName:"p",href:"https://kind.sigs.k8s.io/"},"kind")," cluster by following the instructions at the link. Regardless of which cluster you'd like to use, you can install Weave GitOps by first making sure your default kubeconfig points to the chosen cluster and then running ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops install --app-config-url <configuration repository>"),". The configuration repository is a Git repository that will hold the resource definitions required to manage your applications via GitOps. Please note that these examples are being run with the ",(0,a.kt)("inlineCode",{parentName:"p"},"GITOPS_TOKEN")," environment variable set to a valid GitHub Personal Access Token (PAT) possessing ",(0,a.kt)("inlineCode",{parentName:"p"},"repo")," access. If that were not the case, you would see extra user authentication steps in the output."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"gitops install --app-config-url ssh://git@github.com/example/external.git\n\n\u271a generating manifests\n\u2714 manifests build completed\n\u25ba installing components in wego-system namespace\nCustomResourceDefinition/alerts.notification.toolkit.fluxcd.io created\nCustomResourceDefinition/buckets.source.toolkit.fluxcd.io created\nCustomResourceDefinition/gitrepositories.source.toolkit.fluxcd.io created\nCustomResourceDefinition/helmcharts.source.toolkit.fluxcd.io created\nCustomResourceDefinition/helmreleases.helm.toolkit.fluxcd.io created\nCustomResourceDefinition/helmrepositories.source.toolkit.fluxcd.io created\nCustomResourceDefinition/imagepolicies.image.toolkit.fluxcd.io created\nCustomResourceDefinition/imagerepositories.image.toolkit.fluxcd.io created\nCustomResourceDefinition/imageupdateautomations.image.toolkit.fluxcd.io created\nCustomResourceDefinition/kustomizations.kustomize.toolkit.fluxcd.io created\nCustomResourceDefinition/providers.notification.toolkit.fluxcd.io created\nCustomResourceDefinition/receivers.notification.toolkit.fluxcd.io created\nNamespace/wego-system created\nServiceAccount/wego-system/helm-controller created\nServiceAccount/wego-system/image-automation-controller created\nServiceAccount/wego-system/image-reflector-controller created\nServiceAccount/wego-system/kustomize-controller created\nServiceAccount/wego-system/notification-controller created\nServiceAccount/wego-system/source-controller created\nClusterRole/crd-controller-wego-system created\nClusterRoleBinding/cluster-reconciler-wego-system created\nClusterRoleBinding/crd-controller-wego-system created\nService/wego-system/notification-controller created\nService/wego-system/source-controller created\nService/wego-system/webhook-receiver created\nDeployment/wego-system/helm-controller created\nDeployment/wego-system/image-automation-controller created\nDeployment/wego-system/image-reflector-controller created\nDeployment/wego-system/kustomize-controller created\nDeployment/wego-system/notification-controller created\nDeployment/wego-system/source-controller created\nNetworkPolicy/wego-system/allow-egress created\nNetworkPolicy/wego-system/allow-scraping created\nNetworkPolicy/wego-system/allow-webhooks created\n\u25ce verifying installation\n\u2714 helm-controller: deployment ready\n\u2714 image-automation-controller: deployment ready\n\u2714 image-reflector-controller: deployment ready\n\u2714 kustomize-controller: deployment ready\n\u2714 notification-controller: deployment ready\n\u2714 source-controller: deployment ready\n\u2714 install finished\nDeploy key generated and uploaded to git provider\n\u25ba Writing manifests to disk\n\u25ba Committing and pushing gitops updates for application\n\u25ba Pushing app changes to repository\n\u25ba Applying manifests to the cluster\narete: /tmp/sock-shop>\n")),(0,a.kt)("p",null,"Once you see ",(0,a.kt)("inlineCode",{parentName:"p"},"\u25ba Applying manifests to the cluster"),", your cluster is ready to go with Weave GitOps."),(0,a.kt)("h2",{id:"deploying-with-weave-gitops"},"Deploying with Weave GitOps"),(0,a.kt)("p",null,"Once you have a cluster running Weave GitOps, it's simple to deploy an application like ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microservices-demo/microservices-demo"},(0,a.kt)("em",{parentName:"a"},"Sock Shop")),"."),(0,a.kt)("p",null,"To deploy the ",(0,a.kt)("em",{parentName:"p"},"Sock Shop"),", we need to use ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops add app"),". ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops add app")," will store the GitOps automation support for your application in the ",(0,a.kt)("inlineCode",{parentName:"p"},".weave-gitops")," directory of the configuration repository you specified at install time. The definition of your application can be stored either in a separate repository or in the configuration repository itself (for a simple all-in-one configuration). If you want to store the application resources in the configuration repository, you only need to specify the ",(0,a.kt)("inlineCode",{parentName:"p"},"--url")," flag which will be used for both application and configuration resources; however, this assumes that the application repository URL was passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops install"),". If you want the application resources to be stored separately, you need to specify both ",(0,a.kt)("inlineCode",{parentName:"p"},"--url")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"--app-config-url")," parameters. The ",(0,a.kt)("inlineCode",{parentName:"p"},"--url")," parameter should be the URL of the repository containing the application definition and the ",(0,a.kt)("inlineCode",{parentName:"p"},"--app-config-url")," parameter must be the URL that was used in ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops install"),"."),(0,a.kt)("p",null,"First, let's fork the ",(0,a.kt)("em",{parentName:"p"},"Sock Shop")," repository. You can simply go to the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/microservices-demo/microservices-demo"},"repository")," in ",(0,a.kt)("inlineCode",{parentName:"p"},"GitHub")," and select ",(0,a.kt)("inlineCode",{parentName:"p"},"Fork"),"."),(0,a.kt)("p",null,"Now, we can add the Sock Shop application to the configuration repository so it can be managed through GitOps:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"> gitops add app --url ssh://git@github.com/example/microservices-demo.git --path ./deploy/kubernetes/manifests --app-config-url\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},'ssh://git@github.com/example/external.git --auto-merge\nAdding application:\n\nName: microservices-demo\nURL: ssh://git@github.com/example/microservices-demo.git\nPath: ./deploy/kubernetes/manifests\nBranch: master\nType: kustomize\n\n\u25ce Checking cluster status\n\u2714 GitOps installed\n\u271a Generating application spec manifest\n\u271a Generating GitOps automation manifests\n\u25ba Adding application "microservices-demo" to cluster "kind-kind" and repository\n\u25ba Committing and pushing gitops updates for application\n\u25ba Pushing app changes to repository\n>\n')),(0,a.kt)("p",null,"Here we see all the pods running:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"> kubectl get pods -A\nNAMESPACE            NAME                                           READY   STATUS    RESTARTS   AGE\nkube-system          coredns-558bd4d5db-jgcf2                       1/1     Running   0          9d\nkube-system          coredns-558bd4d5db-sht4v                       1/1     Running   0          9d\nkube-system          etcd-kind-control-plane                        1/1     Running   0          9d\nkube-system          kindnet-tdcd2                                  1/1     Running   0          9d\nkube-system          kube-apiserver-kind-control-plane              1/1     Running   0          9d\nkube-system          kube-controller-manager-kind-control-plane     1/1     Running   0          9d\nkube-system          kube-proxy-mqvbc                               1/1     Running   0          9d\nkube-system          kube-scheduler-kind-control-plane              1/1     Running   0          9d\nlocal-path-storage   local-path-provisioner-547f784dff-mqgjc        1/1     Running   0          9d\nsock-shop            carts-b4d4ffb5c-g82h6                          1/1     Running   0          9d\nsock-shop            carts-db-6c6c68b747-xtlgk                      1/1     Running   0          9d\nsock-shop            catalogue-759cc6b86-jk4gf                      1/1     Running   0          9d\nsock-shop            catalogue-db-96f6f6b4c-865w4                   1/1     Running   0          9d\nsock-shop            front-end-5c89db9f57-99vw6                     1/1     Running   0          9d\nsock-shop            orders-7664c64d75-qlz9d                        1/1     Running   0          9d\nsock-shop            orders-db-659949975f-fggdb                     1/1     Running   0          9d\nsock-shop            payment-7bcdbf45c9-fhl8m                       1/1     Running   0          9d\nsock-shop            queue-master-5f6d6d4796-cs5f6                  1/1     Running   0          9d\nsock-shop            rabbitmq-5bcbb547d7-kfzmn                      2/2     Running   0          9d\nsock-shop            session-db-7cf97f8d4f-bms4c                    1/1     Running   0          9d\nsock-shop            shipping-7f7999ffb7-llkrw                      1/1     Running   0          9d\nsock-shop            user-68df64db9c-7gcg2                          1/1     Running   0          9d\nsock-shop            user-db-6df7444fc-7s6wp                        1/1     Running   0          9d\nwego-system          helm-controller-6dcbff747f-sfp97               1/1     Running   0          9d\nwego-system          image-automation-controller-75f784cfdc-wxwk9   1/1     Running   0          9d\nwego-system          image-reflector-controller-67d6bdcb59-hg2cv    1/1     Running   0          9d\nwego-system          kustomize-controller-5d47cf49fb-b6pmg          1/1     Running   0          9d\nwego-system          notification-controller-7569f7c974-824p9       1/1     Running   0          9d\nwego-system          source-controller-5b976b8dd6-gqrl7             1/1     Running   0          9d\n>\n")),(0,a.kt)("p",null,"We can expose the sock shop in our browser by:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"> kubectl port-forward service/front-end -n sock-shop 8080:80\nForwarding from 127.0.0.1:8080 -> 8079\nForwarding from [::1]:8080 -> 8079\n")),(0,a.kt)("p",null,"and if we visit ",(0,a.kt)("inlineCode",{parentName:"p"},"http://localhost:8080"),", we'l see:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"sock shop",src:n(78928).Z})),(0,a.kt)("p",null,"Pretty simple! Now, let's go back and look at that command in more detail:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"gitops add app \\                                                 # (1)\n   --url ssh://git@github.com/example/microservices-demo.git \\   # (2)\n   --path ./deploy/kubernetes/manifests \\                        # (3)\n   --app-config-url ssh://git@github.com/example/external.git    # (4)\n   --auto-merge                                                  # (5)`\n")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Add an application to a cluster under the control of Weave GitOps"),(0,a.kt)("li",{parentName:"ol"},"The application is defined in the GitHub repository at the specified URL"),(0,a.kt)("li",{parentName:"ol"},"Only the manifests at the specified path within the repository are part of the application"),(0,a.kt)("li",{parentName:"ol"},"Store the management manifests in a separate configuration repository within GitHub; the ",(0,a.kt)("inlineCode",{parentName:"li"},"app-config-url")," parameter says where to store management manifests. The default location (if no ",(0,a.kt)("inlineCode",{parentName:"li"},"app-config-url")," is specified) is to place them in the ",(0,a.kt)("inlineCode",{parentName:"li"},".weave-gitops")," directory within the application repository itself. An actual URL value causes them to be stored in the repository referenced by the URL"),(0,a.kt)("li",{parentName:"ol"},"Don't create a pull request for the management manifests; push them directly to the upstream repository")),(0,a.kt)("h3",{id:"using-helm-charts"},"Using Helm Charts"),(0,a.kt)("p",null,"The application can also be deployed via a helm chart. Applications defined in helm charts can be deployed from either helm repositories or git repositories. In the case of the ",(0,a.kt)("em",{parentName:"p"},"Sock Shop")," application, a helm chart is included in the ",(0,a.kt)("inlineCode",{parentName:"p"},"GitHub")," repository. We only need to make minor changes to the command we used above to switch to a helm chart, but using a helm chart for ",(0,a.kt)("em",{parentName:"p"},"Sock Shop")," requires the target namespace to exist before deploying. By default, the chart would be deployed into the ",(0,a.kt)("inlineCode",{parentName:"p"},"wego-system")," namespace (since we know it exists), but we'd like to put it in the ",(0,a.kt)("inlineCode",{parentName:"p"},"sock-shop")," namespace. So, before we run ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops add app"),", we'll run:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"kubectl create namespace sock-shop\nnamespace/sock-shop created\n>\n")),(0,a.kt)("p",null,"Then, we can run:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},'> gitops add app --url ssh://git@github.com/example/microservices-demo.git --path ./deploy/kubernetes/helm-chart --app-config-url ssh://git@github.com/example/external.git --deployment-type helm --helm-release-target-namespace sock-shop --auto-merge\nAdding application:\n\nName: microservices-demo\nURL: ssh://git@github.com/example/microservices-demo.git\nPath: ./deploy/kubernetes/helm-chart\nBranch: master\nType: helm\n\n\u25ce Checking cluster status\n\u2714 GitOps installed\n\u271a Generating application spec manifest\n\u271a Generating GitOps automation manifests\n\u25ba Adding application "microservices-demo" to cluster "kind-kind" and repository\n\u25ba Committing and pushing gitops updates for application\n\u25ba Pushing app changes to repository\n>\n')),(0,a.kt)("p",null,"Examining this command, we see two new arguments:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"gitops add app \\\n--name microservices-demo\n--url ssh://git@github.com/example/microservices-demo.git \\\n--path ./deploy/kubernetes/helm-chart \\\n--app-config-url ssh://git@github.com/example/external.git\n--deployment-type helm \\                   # (1)\n--helm-release-target-namespace sock-shop  # (2)\n--auto-merge\n")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Since we're pulling the chart from a git repository, we need to explicitly state that we're using a helm chart. If we were using a helm repository, we would use ",(0,a.kt)("inlineCode",{parentName:"li"},"--chart <chart name>")," instead of ",(0,a.kt)("inlineCode",{parentName:"li"},"--path <path to application>")," and the deployment type would be unambiguous"),(0,a.kt)("li",{parentName:"ol"},"The application will be deployed in the namespace specified by ",(0,a.kt)("inlineCode",{parentName:"li"},"--helm-release-target-namespace"))),(0,a.kt)("p",null,"You can check the status of the application by running the ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops get app microservices-demo")," command."),(0,a.kt)("h3",{id:"single-repository-usage"},"Single Repository Usage"),(0,a.kt)("p",null,"As we mentioned above, it's possible to have a single repository perform hold both the application and the configuration. If you place the application manifests in the configuration repository passed to ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops install"),", you can leave off the separate ",(0,a.kt)("inlineCode",{parentName:"p"},"--app-config-url")," parameter. In this case, we would either have had to pass the ",(0,a.kt)("inlineCode",{parentName:"p"},"microservices-demo")," URL to ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops install")," or copy the application manifests into the ",(0,a.kt)("inlineCode",{parentName:"p"},"external")," repository. Let's proceed as if we had initialized the cluster with: ",(0,a.kt)("inlineCode",{parentName:"p"},"gitops install --app-config-url ssh://git@github.com/example/microservices-demo.git"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},'> gitops add app --url ssh://git@github.com/example/microservices-demo.git --path ./deploy/kubernetes/manifests --auto-merge\nAdding application:\n\nName: microservices-demo\nURL: ssh://git@github.com/example/microservices-demo.git\nPath: ./deploy/kubernetes/manifests\nBranch: master\nType: kustomize\n\n\u25ce Checking cluster status\n\u2714 GitOps installed\n\u271a Generating application spec manifest\n\u271a Generating GitOps automation manifests\n\u25ba Adding application "microservices-demo" to cluster "kind-kind" and repository\n\u25ba Committing and pushing gitops updates for application\n\u25ba Pushing app changes to repository\n>\n')),(0,a.kt)("p",null,"So, it's just like the example above except we didn't have to call out the location of the configuration repository. Regardless of whether or not the application manifests are stored in the configuration repository, though, the configuration itself is stored in a special directory (",(0,a.kt)("inlineCode",{parentName:"p"},".weave-gitops"),") at the top level of the configuration repository:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},"> tree .weave-gitops\n.weave-gitops\n\u251c\u2500\u2500 apps\n\u2502\xa0\xa0 \u2514\u2500\u2500 microservices-demo\n\u2502\xa0\xa0     \u251c\u2500\u2500 app.yaml\n\u2502\xa0\xa0     \u251c\u2500\u2500 kustomization.yaml\n\u2502\xa0\xa0     \u251c\u2500\u2500 microservices-demo-gitops-deploy.yaml\n\u2502\xa0\xa0     \u2514\u2500\u2500 microservices-demo-gitops-source.yaml\n\u2514\u2500\u2500 clusters\n    \u2514\u2500\u2500 kind-kind\n        \u251c\u2500\u2500 system\n        \u2502\xa0\xa0 \u251c\u2500\u2500 flux-source-resource.yaml\n        \u2502\xa0\xa0 \u251c\u2500\u2500 flux-system-kustomization-resource.yaml\n        \u2502\xa0\xa0 \u251c\u2500\u2500 flux-user-kustomization-resource.yaml\n        \u2502\xa0\xa0 \u251c\u2500\u2500 gitops-runtime.yaml\n        \u2502\xa0\xa0 \u251c\u2500\u2500 wego-app.yaml\n        \u2502\xa0\xa0 \u2514\u2500\u2500 wego-system.yaml\n        \u2514\u2500\u2500 user\n            \u2514\u2500\u2500 kustomization.yaml\n\n6 directories, 11 files\n")),(0,a.kt)("p",null,"In this case, the ",(0,a.kt)("inlineCode",{parentName:"p"},"apps")," directory contains one app (microservices-demo). The ",(0,a.kt)("inlineCode",{parentName:"p"},"app.yaml")," file looks like:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"---\napiVersion: wego.weave.works/v1alpha1\nkind: Application\nmetadata:\n  labels:\n    wego.weave.works/app-identifier: wego-85414ad27cd476d497d715818deda0c6\n  name: microservices-demo\n  namespace: wego-system\nspec:\n  branch: master\n  config_url: ssh://git@github.com/example/external.git\n  deployment_type: kustomize\n  path: ./deploy/kubernetes/manifests\n  source_type: git\n  url: ssh://git@github.com/example/microservices-demo.git\n")),(0,a.kt)("p",null,"It describes the application and includes a label derived from the URL, path, and branch to prevent multiple applications from referencing the same source within git."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"kustomization.yaml")," file holds a list of application components that will be deployed:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: kustomize.config.k8s.io/v1beta1\nkind: Kustomization\nmetadata:\n  name: microservices-demo\n  namespace: wego-system\nresources:\n  - app.yaml\n  - microservices-demo-gitops-deploy.yaml\n  - microservices-demo-gitops-source.yaml\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"microservices-demo-gitops-source.yaml")," file tells flux the location (repository) containing the application. It has a special ",(0,a.kt)("inlineCode",{parentName:"p"},"ignore")," section that skips ",(0,a.kt)("inlineCode",{parentName:"p"},".weave-gitops")," to support keeping an application in the configuration repository:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: source.toolkit.fluxcd.io/v1beta1\nkind: GitRepository\nmetadata:\n  name: microservices-demo\n  namespace: wego-system\nspec:\n  ignore: |-\n    .weave-gitops/\n    .git/\n    .gitignore\n    .gitmodules\n    .gitattributes\n    *.jpg\n    *.jpeg\n    *.gif\n    *.png\n    *.wmv\n    *.flv\n    *.tar.gz\n    *.zip\n    .github/\n    .circleci/\n    .travis.yml\n    .gitlab-ci.yml\n    appveyor.yml\n    .drone.yml\n    cloudbuild.yaml\n    codeship-services.yml\n    codeship-steps.yml\n    **/.goreleaser.yml\n    **/.sops.yaml\n    **/.flux.yaml\n  interval: 30s\n  ref:\n    branch: master\n  url: https://github.com/example/microservices-demo.git\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"microservices-demo-gitops-deploy.yaml")," file defines the path within the repository and the sync interval for the application:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"---\napiVersion: kustomize.toolkit.fluxcd.io/v1beta2\nkind: Kustomization\nmetadata:\n  name: microservices-demo\n  namespace: wego-system\nspec:\n  interval: 1m0s\n  path: ./deploy/kubernetes/manifests\n  prune: true\n  sourceRef:\n    kind: GitRepository\n    name: microservices-demo\n")),(0,a.kt)("p",null,"(This will look different in the case of a helm chart; it will hold a ",(0,a.kt)("inlineCode",{parentName:"p"},"HelmRelease")," rather than a ",(0,a.kt)("inlineCode",{parentName:"p"},"Kustomization"),")"),(0,a.kt)("p",null,"Finally, the ",(0,a.kt)("inlineCode",{parentName:"p"},"clusters")," directory has a subdirectory for each cluster defining which applications will run there. The ",(0,a.kt)("inlineCode",{parentName:"p"},"user/kustomization.yaml")," file in a specific cluster directory has a ",(0,a.kt)("inlineCode",{parentName:"p"},"resources")," section containing a list of applications references:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"resources:\n  - ../../../apps/microservices-demo\n")),(0,a.kt)("h3",{id:"using-pull-requests"},"Using Pull Requests"),(0,a.kt)("p",null,"We've reached the all-singing, all-dancing case now. This is the way most people will actually use Weave GitOps in a real environment. Whether you use the default application repository model or have a separate configuration repository, you can support reviewing and auditing changes to your GitOps resources via ",(0,a.kt)("em",{parentName:"p"},"Pull Requests"),". (Also, as a practical matter, many people don't allow direct merges to their repositories without pull requests anyway)"),(0,a.kt)("p",null,"In order to use pull requests for your GitOps resources, you simply need to leave off the ",(0,a.kt)("inlineCode",{parentName:"p"},"--auto-merge")," flag we've been passing so far (in other words, using pull requests is the default). For example, if we run the previous command without ",(0,a.kt)("inlineCode",{parentName:"p"},"--auto-merge"),", we see different output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-console"},'> gitops add app --url ssh://git@github.com/example/microservices-demo.git --path ./deploy/kubernetes/manifests\nAdding application:\n\nName: microservices-demo\nURL: ssh://git@github.com/example/microservices-demo.git\nPath: ./deploy/kubernetes/manifests\nBranch: master\nType: kustomize\n\n\u25ce Checking cluster status\n\u2714 GitOps installed\n\u271a Generating application spec manifest\n\u271a Generating GitOps automation manifests\n\u25ba Adding application "microservices-demo" to cluster "kind-kind" and repository\nPull Request created: https://github.com/example/external/pull/14\n\n>\n')),(0,a.kt)("p",null,"Note the line: ",(0,a.kt)("inlineCode",{parentName:"p"},"Pull Request created: https://github.com/example/external/pull/14"),". If we were to go to that GitHub repository and merge the pull request, the app would then be deployed."),(0,a.kt)("p",null,"Hopefully, this example has given you a good understanding of how to deploy applications with Weave GitOps. Thanks for reading!"))}m.isMDXComponent=!0},78928:function(e,t,n){"use strict";t.Z=n.p+"assets/images/sock-shop-d6f3139b052fef35a1d86a6712b0e6bd.png"}}]);